//다이아몬드 문제(Diamond Problem)는 C++에서 다중 상속을 사용할 때 발생할 수 있는 문제로, 두 개의 경로를 통해 동일한 기본 클래스를 상속받는 경우입니다.이를 해결하기 위해 가상 상속(Virtual Inheritance)을 사용할 수 있습니다.가상 상속을 사용하면 기본 클래스의 인스턴스가 한 번만 생성되어 다이아몬드 문제를 해결할 수 있습니다.
//
//### 다이아몬드 문제
//
//다이아몬드 문제는 다음과 같은 구조를 가질 때 발생합니다 :
//
//```cpp
//class A {
//public:
//    void show() {
//        std::cout << "Class A" << std::endl;
//    }
//};
//
//class B : public A {};
//
//class C : public A {};
//
//class D : public B, public C {};
//
//int main() {
//    D obj;
//    obj.show(); // 모호성 오류 발생
//    return 0;
//}
//```
//
//위 코드에서는 `D` 클래스가 `B`와 `C`를 통해 두 번 `A`를 상속받기 때문에, `obj.show()` 호출 시 모호성 오류가 발생합니다.
//
//### 가상 상속으로 해결
//
//가상 상속을 사용하여 다이아몬드 문제를 해결할 수 있습니다.가상 상속을 통해 `A` 클래스의 인스턴스가 한 번만 생성되도록 합니다.
//
//```cpp
//#include <iostream>
//
//class A {
//public:
//    void show() {
//        std::cout << "Class A" << std::endl;
//    }
//};
//
//// 가상 상속
//class B : virtual public A {};
//
//class C : virtual public A {};
//
//class D : public B, public C {};
//
//int main() {
//    D obj;
//    obj.show(); // Class A 출력
//    return 0;
//}
//```
//
//### 설명
//
//1. * *가상 상속 선언 * *:
//-`B`와 `C` 클래스에서 `A`를 상속받을 때 `virtual` 키워드를 사용합니다.
//- `class B : virtual public A`와 같이 가상 상속을 선언합니다.
//
//2. * *다이아몬드 문제 해결 * *:
//-`D` 클래스가 `B`와 `C`를 상속받을 때, `A` 클래스의 인스턴스는 한 번만 생성됩니다.
//- `D` 객체에서 `A`의 멤버 함수 `show()`를 호출할 때, 모호성 오류가 발생하지 않습니다.
//
//### 가상 상속의 동작 방식
//
//가상 상속을 사용하면 상속 계층 구조에서 가장 마지막에 있는 클래스가 실제로 기본 클래스의 인스턴스를 생성합니다.이로 인해 다이아몬드 문제가 해결됩니다.
//
//### 결론
//
//다이아몬드 문제는 C++에서 다중 상속을 사용할 때 발생할 수 있는 문제로, 가상 상속을 사용하여 해결할 수 있습니다.가상 상속을 사용하면 기본 클래스의 인스턴스가 한 번만 생성되어 모호성 문제를 방지할 수 있습니다.이를 통해 C++에서 다형성과 상속의 유연성을 유지하면서 안정적인 코드를 작성할 수 있습니다.